
jvm 维持两个堆空间, java heap和native heap。

The Java heap contains the instances of Java objects and is often referred to as 'the heap'. It is the Java heap that is maintained by Garbage Collection, and it is the Java heap that is changed by the command-line heap settings. The Java heap is allocated using mmap, or shmat if large page support is requested. The maximum size of the Java heap is preallocated during JVM startup as one contiguous area, even if the minimum heap size setting is lower.

The native, or system heap, is allocated by using the underlying malloc and free mechanisms of the operating system, and is used for the underlying implementation of particular Java objects; for example:

1) Compiled code generated by the Just In Time (JIT) Compiler
2) Threads to map to Java threads



## not understanding
The G1 GC uses independent Remembered Sets (RSets) to track references into regions. Independent RSets enable parallel and independent collection of regions because only a region's RSet must be scanned for references into that region, instead of the whole heap. The G1 GC uses a post-write barrier to record changes to the heap and update the RSets.


## SATB
 G1 GC uses the Snapshot-At-The-Beginning (SATB) algorithm, which takes a snapshot of the set of live objects in the heap at the start of a marking cycle. The set of live objects is composed of the live objects in the snapshot, and the objects allocated since the start of the marking cycle. The G1 GC marking algorithm uses a pre-write barrier to record and mark objects that are part of the logical snapshot.

 ## Young Garbage Collections
 The G1 GC satisfies most allocation requests from regions added to the eden set of regions. During a young garbage collection, the G1 GC collects both the eden regions and the survivor regions from the previous garbage collection. The live objects from the eden and survivor regions are copied, or evacuated, to a new set of regions. The destination region for a particular object depends upon the object's age; an object that has aged sufficiently evacuates to an old generation region (that is, promoted); otherwise, the object evacuates to a survivor region and will be included in the CSet of the next young or mixed garbage collection.


while twitter tell me there is only 18 words left i could wirte, so i write here :smiley:
I think that the region size has bigger impact on the jvm performance than the region amount, because G1 always choose part of regions to collect to get a excepted pause time, so the region amount does'n impact the jvm performance, am i wrong?
ps: if you can introduce me some articles about this, it would be wonderful.



 MaxPermSize      = 1073741824 (1024.0MB)
 G1HeapRegionSize = 33554432 (32.0MB)

 Heap Usage:
 G1 Heap:
    regions  = 3200
    capacity = 107374182400 (102400.0MB)
    used     = 75442671088 (71947.73777770996MB)
    free     = 31931511312 (30452.26222229004MB)
    70.26146267354488% used
 G1 Young Generation:
 Eden Space:
    regions  = 495
    capacity = 39258685440 (37440.0MB)
    used     = 16609443840 (15840.0MB)
    free     = 22649241600 (21600.0MB)
    42.30769230769231% used
 Survivor Space:
    regions  = 6
    capacity = 201326592 (192.0MB)
    used     = 201326592 (192.0MB)
    free     = 0 (0.0MB)
    100.0% used
 G1 Old Generation:
    regions  = 1754
    capacity = 67914170368 (64768.0MB)
    used     = 58631900656 (55915.73777770996MB)
    free     = 9282269712 (8852.262222290039MB)
    86.3323520530354% used
 Perm Generation:
    capacity = 1073741824 (1024.0MB)
    used     = 77916288 (74.3067626953125MB)
    free     = 995825536 (949.6932373046875MB)
    7.256519794464111% used

 94616 interned Strings occupying 8784672 bytes.
